<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gi√°ng Sinh 2025 - Stardust Delivery</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at center, #0e1018 0%, #000000 100%);
        height: 100vh;
        font-family: "Times New Roman", serif;
        user-select: none;
      }

      canvas {
        display: block;
        cursor: default;
      }

      /* --- UI ELEMENTS --- */
      .btn-circle {
        position: absolute;
        top: 20px;
        width: 45px;
        height: 45px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: #ffd700;
        font-size: 1.4rem;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 101;
        backdrop-filter: blur(5px);
        transition: all 0.3s;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
      }
      .btn-circle:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: scale(1.1);
      }
      .settings-btn {
        right: 20px;
      }
      .fullscreen-btn {
        right: 80px;
        font-size: 1.8rem;
      }

      .controls {
        position: absolute;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: #fff;
        width: 220px;
        z-index: 100;
        font-family: "Arial", sans-serif;
        transition: all 0.4s;
        transform-origin: top right;
      }
      .controls.hidden {
        opacity: 0;
        transform: scale(0.8) translateY(-20px);
        visibility: hidden;
        pointer-events: none;
      }

      .control-group {
        margin-bottom: 12px;
      }
      .control-group label {
        display: flex;
        justify-content: space-between;
        font-size: 0.75rem;
        margin-bottom: 5px;
        color: #ffd700;
        font-weight: bold;
        text-transform: uppercase;
      }
      input[type="range"] {
        width: 100%;
        cursor: pointer;
        accent-color: #ff3333;
        height: 4px;
      }
      button.action-btn {
        width: 100%;
        padding: 10px;
        margin-top: 5px;
        background: linear-gradient(45deg, #d32f2f, #b71c1c);
        border: none;
        color: white;
        border-radius: 5px;
        font-weight: bold;
        cursor: pointer;
      }

      .message {
        position: absolute;
        bottom: 40px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        animation: fadeInMessage 2s forwards;
        animation-delay: 1s;
      }
      @keyframes fadeInMessage {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .main-text {
        font-size: 2.5rem;
        font-weight: 800;
        letter-spacing: 3px;
        background: linear-gradient(to bottom, #fff 20%, #ffd700 80%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 40px rgba(255, 215, 0, 0.4);
      }
    </style>
  </head>
  <body>
    <div
      class="btn-circle fullscreen-btn"
      onclick="toggleFullScreen()"
      title="To√†n m√†n h√¨nh"
    >
      ‚õ∂
    </div>
    <div
      class="btn-circle settings-btn"
      onclick="toggleControls()"
      title="C√†i ƒë·∫∑t"
    >
      ‚öôÔ∏è
    </div>

    <div class="controls" id="controlPanel">
      <div class="control-group">
        <label>üé• G√≥c Nh√¨n</label>
        <input
          type="range"
          id="angleRange"
          min="0"
          max="1.4"
          step="0.05"
          value="0.3"
        />
      </div>
      <div class="control-group">
        <label>üå≤ ƒê·ªô R·ªông</label>
        <input
          type="range"
          id="widthRange"
          min="200"
          max="500"
          step="10"
          value="340"
        />
      </div>
      <div class="control-group">
        <label>üöÄ T·ªëc ƒê·ªô R√°p</label>
        <input
          type="range"
          id="assemblySpeedRange"
          min="0.1"
          max="5"
          step="0.1"
          value="1.5"
        />
      </div>
      <div class="control-group">
        <label>üîÑ T·ªëc ƒê·ªô Xoay</label>
        <input
          type="range"
          id="rotationSpeedRange"
          min="0"
          max="0.02"
          step="0.001"
          value="0.004"
        />
      </div>
      <button class="action-btn" onclick="resetAnimation()">üé¨ R√°p L·∫°i</button>
    </div>

    <div class="message">
      <div class="main-text">Merry Christmas</div>
    </div>

    <canvas id="xmasTree3D"></canvas>

    <script>
      const canvas = document.getElementById("xmasTree3D");
      const ctx = canvas.getContext("2d");

      const controlPanel = document.getElementById("controlPanel");
      const settingsBtn = document.querySelector(".settings-btn");
      const fullscreenBtn = document.querySelector(".fullscreen-btn");

      function toggleControls() {
        controlPanel.classList.toggle("hidden");
        settingsBtn.innerHTML = controlPanel.classList.contains("hidden")
          ? "‚öôÔ∏è"
          : "‚úñ";
      }

      function toggleFullScreen() {
        if (!document.fullscreenElement) {
          try {
            document.documentElement.requestFullscreen();
          } catch (e) {}
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
        }
      }
      document.addEventListener(
        "fullscreenchange",
        () => (fullscreenBtn.innerHTML = document.fullscreenElement ? "‚Üô" : "‚õ∂")
      );

      // Config
      const angleInput = document.getElementById("angleRange");
      const widthInput = document.getElementById("widthRange");
      const assemblySpeedInput = document.getElementById("assemblySpeedRange");
      const rotationSpeedInput = document.getElementById("rotationSpeedRange");

      let width, height;
      let renderList = [],
        snow = [],
        magicParticles = [];
      let santa,
        santaTrail = [],
        fallingGifts = [];
      let animationFrameCount = 0;

      const config = {
        treeHeight: 460,
        trunkHeight: 70,
        trunkRadius: 35,
        baseRadius: parseInt(widthInput.value),
        leafCount: 3800,
        lightCount: 450,
        giftCount: 16,
        stockingCount: 12,
        layerCount: 9,
        focalLength: 850,
        cameraZ: -1150,
        cameraXAngle: parseFloat(angleInput.value),
        rotationSpeed: parseFloat(rotationSpeedInput.value),
        assemblySpeedMult: parseFloat(assemblySpeedInput.value),
        autoRotate: true,
        lightSpiralTurns: 7,
        // TƒÉng th·ªùi gian bay ƒë·ªÉ ƒë∆∞·ªùng bay ngang ch·∫≠m h∆°n ch√∫t
        santaFlightDuration: 1800,
        santaWaitDuration: 200,
      };

      let currentAngleY = 0;
      let mouseX = 0,
        mouseY = 0;
      let cosCamX, sinCamX;

      // --- GLOBAL STATES ---
      let globalLightState = {
        mode: "WAVE",
        wavePos: 0,
        blinkOn: false,
        cycleFrame: 0,
      };
      let santaState = { flying: true, timer: 0, giftDropped: false };

      function updateCamera() {
        config.cameraXAngle = -parseFloat(angleInput.value);
        cosCamX = Math.cos(config.cameraXAngle);
        sinCamX = Math.sin(config.cameraXAngle);
      }
      updateCamera();
      function updateTreeWidth() {
        config.baseRadius = parseInt(widthInput.value);
        resetAnimation();
      }

      angleInput.addEventListener("input", updateCamera);
      widthInput.addEventListener("input", updateTreeWidth);
      rotationSpeedInput.addEventListener(
        "input",
        () => (config.rotationSpeed = parseFloat(rotationSpeedInput.value))
      );
      assemblySpeedInput.addEventListener(
        "input",
        () => (config.assemblySpeedMult = parseFloat(assemblySpeedInput.value))
      );

      // --- 3D Base ---
      class Point3D {
        constructor(tx, ty, tz) {
          this.tx = tx;
          this.ty = ty;
          this.tz = tz;
          this.x = (Math.random() - 0.5) * 6000;
          this.y = (Math.random() - 0.5) * 6000;
          this.z = (Math.random() - 0.5) * 6000;
          this.delay = Math.random() * 200;
          this.baseSpeed = 0.02 + Math.random() * 0.04;
          this.rz = 0;
          this.sx = 0;
          this.sy = 0;
          this.scale = 1;
        }
        updatePosition(frame) {
          if (frame < this.delay) return;
          let currentSpeed = this.baseSpeed * config.assemblySpeedMult;
          if (currentSpeed > 0.6) currentSpeed = 0.6;
          this.x += (this.tx - this.x) * currentSpeed;
          this.y += (this.ty - this.y) * currentSpeed;
          this.z += (this.tz - this.z) * currentSpeed;
        }
        project(angleY) {
          const cosY = Math.cos(angleY);
          const sinY = Math.sin(angleY);
          let x1 = this.x * cosY - this.z * sinY;
          let y1 = this.y;
          let z1 = this.x * sinY + this.z * cosY;
          let y2 = y1 * cosCamX - z1 * sinCamX;
          let z2 = y1 * sinCamX + z1 * cosCamX;
          this.rz = z2;
          const zPerspective = z2 - config.cameraZ;
          if (zPerspective > 100) {
            this.scale = config.focalLength / zPerspective;
            this.sx = width / 2 + x1 * this.scale;
            let viewOffset = parseFloat(angleInput.value) * 150;
            this.sy = height / 2 - y2 * this.scale + height * 0.15 + viewOffset;
          } else {
            this.scale = 0;
          }
        }
      }

      // --- SANTA SLEIGH (QU·ª∏ ƒê·∫†O M·ªöI: BAY NGANG ƒê·ªàNH) ---
      class SantaSleigh extends Point3D {
        constructor() {
          super(0, 0, 0);
          this.baseSize = 25;
          // ƒê·ªô cao bay: Cao h∆°n ƒë·ªânh c√¢y v√† ng√¥i sao m·ªôt ch√∫t (kho·∫£ng 150 ƒë∆°n v·ªã)
          this.flightHeight = config.trunkHeight + config.treeHeight + 150;
        }

        updateFlightPath(progress) {
          // progress 0 -> 1

          // X: Bay t·ª´ tr√°i (-3500) sang ph·∫£i (+3500)
          this.tx = (progress - 0.5) * 7000;

          // Y: Gi·ªØ nguy√™n ƒë·ªô cao tr√™n ƒë·ªânh
          this.ty = this.flightHeight;

          // Z: Bay ngay tr√™n tr·ª•c gi·ªØa c√¢y
          this.tz = 0;

          this.x = this.tx;
          this.y = this.ty;
          this.z = this.tz;

          // V√πng th·∫£ qu√†: R·∫•t h·∫πp ·ªü gi·ªØa (khi ngay tr√™n ƒë·ªânh)
          return progress > 0.49 && progress < 0.51;
        }

        draw(ctx, currentTreeRotation) {
          if (this.scale <= 0 || !santaState.flying) return;

          ctx.save();
          ctx.translate(this.sx, this.sy);

          // L·∫≠t tr·ª•c X ƒë·ªÉ tu·∫ßn l·ªôc ƒëi tr∆∞·ªõc
          ctx.scale(-this.scale, this.scale);

          // Nghi√™ng nh·∫π theo tr·ª•c X ƒë·ªÉ t·∫°o c·∫£m gi√°c chuy·ªÉn ƒë·ªông
          let tilt = (this.tx / 3500) * 0.1;
          ctx.rotate(-tilt);

          // --- V·∫º CHI TI·∫æT (Gi·ªØ nguy√™n) ---
          for (let i = 1; i <= 4; i++) {
            let xOffset = i * 35;
            let grdBody = ctx.createRadialGradient(
              xOffset - 2,
              8,
              2,
              xOffset,
              10,
              15
            );
            grdBody.addColorStop(0, "#A0522D");
            grdBody.addColorStop(1, "#603010");
            ctx.fillStyle = grdBody;
            ctx.beginPath();
            ctx.ellipse(xOffset, 10, 14, 9, 0, 0, Math.PI * 2);
            ctx.fill();
            let grdHead = ctx.createRadialGradient(
              xOffset + 12,
              5,
              1,
              xOffset + 15,
              5,
              8
            );
            grdHead.addColorStop(0, "#B06030");
            grdHead.addColorStop(1, "#703815");
            ctx.fillStyle = grdHead;
            ctx.beginPath();
            ctx.ellipse(xOffset + 15, 5, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#D2B48C";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(xOffset + 15, 0);
            ctx.lineTo(xOffset + 18, -8);
            ctx.lineTo(xOffset + 22, -10);
            ctx.moveTo(xOffset + 15, 0);
            ctx.lineTo(xOffset + 12, -8);
            ctx.lineTo(xOffset + 8, -10);
            ctx.stroke();
          }
          let grdNose = ctx.createRadialGradient(155, 5, 0, 155, 5, 5);
          grdNose.addColorStop(0, "#ffcccc");
          grdNose.addColorStop(1, "#800000");
          ctx.fillStyle = grdNose;
          ctx.beginPath();
          ctx.arc(155, 5, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,215,0, 0.4)";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(140, 0);
          ctx.stroke();
          // Xe tr∆∞·ª£t
          let grdSleigh = ctx.createLinearGradient(0, -25, 0, 15);
          grdSleigh.addColorStop(0, "#ff6666");
          grdSleigh.addColorStop(1, "#8B0000");
          ctx.fillStyle = grdSleigh;
          ctx.beginPath();
          ctx.moveTo(-70, -25);
          ctx.lineTo(10, -25);
          ctx.quadraticCurveTo(30, -25, 30, 0);
          ctx.lineTo(20, 15);
          ctx.lineTo(-60, 15);
          ctx.quadraticCurveTo(-80, 15, -70, -25);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "#C0C0C0";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(-80, 20);
          ctx.lineTo(40, 20);
          ctx.moveTo(-70, 15);
          ctx.lineTo(-75, 20);
          ctx.moveTo(20, 15);
          ctx.lineTo(25, 20);
          ctx.stroke();
          // √îng gi√† Noel
          let grdSantaBody = ctx.createRadialGradient(
            -25,
            -30,
            5,
            -20,
            -25,
            20
          );
          grdSantaBody.addColorStop(0, "#ff4d4d");
          grdSantaBody.addColorStop(1, "#b30000");
          ctx.fillStyle = grdSantaBody;
          ctx.beginPath();
          ctx.ellipse(-20, -25, 18, 14, Math.PI / 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#FFE0BD";
          ctx.beginPath();
          ctx.arc(-20, -40, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#D32F2F";
          ctx.beginPath();
          ctx.moveTo(-28, -42);
          ctx.lineTo(-12, -42);
          ctx.lineTo(-20, -58);
          ctx.fill();
          let grdBeard = ctx.createRadialGradient(-20, -35, 2, -20, -32, 12);
          grdBeard.addColorStop(0, "#ffffff");
          grdBeard.addColorStop(1, "#d9d9d9");
          ctx.fillStyle = grdBeard;
          ctx.beginPath();
          ctx.arc(-20, -35, 10, 0, Math.PI);
          ctx.moveTo(-30, -35);
          ctx.quadraticCurveTo(-32, -25, -20, -20);
          ctx.moveTo(-10, -35);
          ctx.quadraticCurveTo(-8, -25, -20, -20);
          ctx.fill();

          ctx.restore();
        }
      }

      // --- L·ªöP QU√Ä ƒêANG R∆†I ---
      class FallingGift extends Point3D {
        constructor(startX, startY, startZ) {
          super(startX, startY, startZ);
          this.x = startX;
          this.y = startY;
          this.z = startZ;
          this.vy = 0;
          this.gravity = 0.5;
          // ƒêi·ªÉm d·ª´ng: R∆°i xu·ªëng kho·∫£ng gi·ªØa th√¢n c√¢y
          this.targetY =
            config.trunkHeight +
            config.treeHeight * 0.3 +
            Math.random() * (config.treeHeight * 0.3);
          this.isLanded = false;
        }
        updateFall() {
          if (this.isLanded) return;
          this.vy += this.gravity;
          this.y += this.vy;
          if (this.y >= this.targetY) {
            this.y = this.targetY;
            this.isLanded = true;
          }
        }
        draw(ctx) {
          if (this.scale <= 0) return;
          let s = (24 + Math.random() * 5) * this.scale;
          let boxColor = Math.random() > 0.5 ? "#d32f2f" : "#ffd700";
          let ribbonColor = boxColor === "#d32f2f" ? "#ffffff" : "#d32f2f";

          ctx.fillStyle = boxColor;
          ctx.fillRect(this.sx - s / 2, this.sy - s / 2, s, s);
          ctx.fillStyle = ribbonColor;
          let ribbonWidth = s * 0.2;
          ctx.fillRect(
            this.sx - ribbonWidth / 2,
            this.sy - s / 2,
            ribbonWidth,
            s
          );
          ctx.fillRect(
            this.sx - s / 2,
            this.sy - ribbonWidth / 2,
            s,
            ribbonWidth
          );
        }
      }

      // --- V·ªÜT S√ÅNG B·ª§I SAO (STARDUST TRAIL) ---
      class SantaTrailParticle extends Point3D {
        constructor(x, y, z) {
          super(x, y, z);
          // T·∫£n m√°t ng·∫´u nhi√™n ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng b·ª•i
          this.x = x + (Math.random() - 0.5) * 25;
          this.y = y + (Math.random() - 0.5) * 15;
          this.z = z + (Math.random() - 0.5) * 25;
          this.life = 1.0;
          // M√†u s·∫Øc: V√†ng nh·∫°t, tr·∫Øng, xanh nh·∫°t (m√†u sao)
          const colors = [60, 50, 200, 0];
          this.colorH = colors[Math.floor(Math.random() * colors.length)];
          this.baseSize = 1 + Math.random() * 2.5; // H·∫°t nh·ªè
        }
        updateLife() {
          this.life -= 0.025;
        } // Tan bi·∫øn nhanh v·ª´a ph·∫£i
        draw(ctx) {
          if (this.scale <= 0 || this.life <= 0) return;
          ctx.save();
          ctx.globalAlpha = this.life * 0.7; // H∆°i trong su·ªët

          // M√†u s√°ng, ƒë·ªô b√£o h√≤a th·∫•p ƒë·ªÉ gi·ªëng b·ª•i sao
          ctx.fillStyle = `hsl(${this.colorH}, 80%, ${
            80 + Math.random() * 20
          }%)`;

          let s = this.scale * this.baseSize * this.life;
          ctx.beginPath();
          ctx.arc(this.sx, this.sy, s, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      class SnowBase extends Point3D {
        constructor() {
          super(0, 0, 0);
          this.radius = config.baseRadius * 1.5;
        }
        draw(ctx) {
          if (this.scale <= 0) return;
          ctx.save();
          ctx.translate(this.sx, this.sy);
          ctx.scale(1, 0.25);
          let r = this.radius * this.scale;
          let grdShadow = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 0.6);
          grdShadow.addColorStop(0, "rgba(0, 0, 0, 0.8)");
          grdShadow.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = grdShadow;
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
          ctx.fill();
          let grdSnow = ctx.createRadialGradient(0, 0, r * 0.3, 0, 0, r * 1.2);
          grdSnow.addColorStop(0, "rgba(255, 255, 255, 0.15)");
          grdSnow.addColorStop(0.6, "rgba(255, 255, 255, 0.05)");
          grdSnow.addColorStop(1, "rgba(255, 255, 255, 0)");
          ctx.fillStyle = grdSnow;
          ctx.beginPath();
          ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      class TrunkPart extends Point3D {
        constructor(tx, ty, tz) {
          super(tx, ty, tz);
          this.delay = Math.random() * 60;
          const l = 15 + Math.random() * 10;
          this.color = `hsl(25, 30%, ${l}%)`;
          this.baseSize = 4;
        }
        draw(ctx) {
          if (this.scale <= 0) return;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.sx, this.sy, this.baseSize * this.scale, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      class DirectionalLeaf extends Point3D {
        constructor(tx, ty, tz, color) {
          super(tx, ty, tz);
          this.color = color;
          this.outwardAngle = Math.atan2(tz, tx);
          this.leafLen = 15 + Math.random() * 10;
          this.spread = 0.5;
        }
        draw(ctx, currentTreeRotation) {
          if (this.scale <= 0) return;
          let finalAngle = this.outwardAngle + currentTreeRotation;
          let dirX = Math.cos(finalAngle);
          let drawLen = this.leafLen * this.scale;

          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2 * this.scale;
          ctx.lineCap = "round";

          ctx.beginPath();
          ctx.moveTo(this.sx, this.sy);
          ctx.lineTo(this.sx + dirX * drawLen, this.sy + drawLen * 0.8);
          ctx.moveTo(this.sx, this.sy);
          ctx.lineTo(
            this.sx + Math.cos(finalAngle - this.spread) * drawLen * 0.8,
            this.sy + drawLen * 0.9
          );
          ctx.moveTo(this.sx, this.sy);
          ctx.lineTo(
            this.sx + Math.cos(finalAngle + this.spread) * drawLen * 0.8,
            this.sy + drawLen * 0.9
          );
          ctx.stroke();
        }
      }

      class Light extends Point3D {
        constructor(tx, ty, tz) {
          super(tx, ty, tz);
          const colors = [
            "#ff3333",
            "#ffdd00",
            "#44e0ff",
            "#ffffff",
            "#ff00ff",
            "#00ff00",
          ];
          this.baseColor = colors[Math.floor(Math.random() * colors.length)];
          this.baseSize = 4;
          this.delay += 100;
          this.opacityMultiplier = 0;
          this.normalizedHeight = (ty - config.trunkHeight) / config.treeHeight;
        }
        draw(ctx, frame) {
          if (this.scale <= 0) return;
          let fadeSpeed = 0.01 * config.assemblySpeedMult;
          if (frame > this.delay && this.opacityMultiplier < 1)
            this.opacityMultiplier += fadeSpeed;
          if (this.opacityMultiplier <= 0) return;

          let intensity = 0.1;

          if (globalLightState.mode === "WAVE") {
            let wavePos = globalLightState.wavePos;
            let h = this.normalizedHeight;
            let dist = wavePos - h;

            if (dist > 0) {
              let base = 0.5;
              if (wavePos > 1.0) {
                let finishProgress = (wavePos - 1.0) / 0.2;
                if (finishProgress > 1) finishProgress = 1;
                base = 0.5 + 0.5 * finishProgress;
              }
              intensity = base;
              if (dist < 0.3) {
                let head = 1 - dist / 0.3;
                intensity += 0.5 * head;
              }
            }
          } else if (globalLightState.mode === "BLINK") {
            intensity = globalLightState.blinkOn ? 1.0 : 0.1;
          }

          if (intensity > 1) intensity = 1;

          let finalOpacity = intensity * this.opacityMultiplier;
          let s = this.scale;

          if (intensity > 0.6) {
            ctx.globalAlpha = finalOpacity * 0.5;
            ctx.fillStyle = this.baseColor;
            ctx.beginPath();
            ctx.arc(this.sx, this.sy, this.baseSize * s * 4, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = finalOpacity;
          ctx.fillStyle = this.baseColor;
          ctx.beginPath();
          ctx.arc(this.sx, this.sy, this.baseSize * s, 0, Math.PI * 2);
          ctx.fill();

          if (intensity > 0.9) {
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(this.sx, this.sy, this.baseSize * s * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1.0;
        }
      }

      class GiftBox extends Point3D {
        constructor(tx, ty, tz) {
          super(tx, ty, tz);
          this.baseSize = 24 + Math.random() * 16;
          this.delay += 150;
          this.boxColor = Math.random() > 0.5 ? "#d32f2f" : "#ffd700";
          this.ribbonColor =
            this.boxColor === "#d32f2f" ? "#ffffff" : "#d32f2f";
        }
        draw(ctx) {
          if (this.scale <= 0) return;
          let s = this.baseSize * this.scale;
          if (s < 4) return;
          ctx.fillStyle = this.boxColor;
          ctx.fillRect(this.sx - s / 2, this.sy - s / 2, s, s);
          ctx.fillStyle = this.ribbonColor;
          let ribbonWidth = s * 0.2;
          ctx.fillRect(
            this.sx - ribbonWidth / 2,
            this.sy - s / 2,
            ribbonWidth,
            s
          );
          ctx.fillRect(
            this.sx - s / 2,
            this.sy - ribbonWidth / 2,
            s,
            ribbonWidth
          );
        }
      }

      class Stocking extends Point3D {
        constructor(tx, ty, tz) {
          super(tx, ty, tz);
          this.baseSize = 20 + Math.random() * 12;
          this.delay += 180;
        }
        draw(ctx) {
          if (this.scale <= 0) return;
          let s = this.baseSize * this.scale;
          if (s < 4) return;
          ctx.fillStyle = "#d32f2f";
          ctx.beginPath();
          ctx.fillRect(this.sx - s / 2.5, this.sy - s / 2, s / 1.8, s);
          ctx.fillRect(this.sx - s / 2.5, this.sy + s / 4, s, s / 2.5);
          ctx.fill();
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.fillRect(
            this.sx - s / 2,
            this.sy - s / 2 - s * 0.1,
            s / 1.2,
            s * 0.3
          );
          ctx.fill();
        }
      }

      class StarTop extends Point3D {
        constructor() {
          super(0, config.trunkHeight + config.treeHeight + 8, 0);
          this.outerRadius = 50;
          this.innerRadius = 25;
          this.delay = 200;
          this.startScale = 0;
        }
        draw(ctx, frame) {
          if (this.scale <= 0) return;
          let growSpeed = 0.03 * config.assemblySpeedMult;
          if (frame > this.delay)
            this.startScale += (1 - this.startScale) * growSpeed;
          if (this.startScale < 0.01) return;

          ctx.save();
          ctx.translate(this.sx, this.sy);
          ctx.scale(this.startScale, this.startScale);
          ctx.rotate(frame * 0.01);

          let starGlow = 0.4;
          if (globalLightState.mode === "WAVE") {
            if (
              globalLightState.wavePos > 0.95 &&
              globalLightState.wavePos < 1.25
            )
              starGlow = 1.0;
          } else {
            starGlow = globalLightState.blinkOn ? 1.0 : 0.2;
          }

          ctx.globalAlpha = starGlow * 0.6;
          ctx.fillStyle = "#ffd700";
          ctx.beginPath();
          ctx.arc(0, 0, this.outerRadius * this.scale * 2, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalAlpha = 1;
          ctx.fillStyle = starGlow > 0.9 ? "#ffffff" : "#ffd700";
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            ctx.lineTo(
              Math.cos(((18 + i * 72) * Math.PI) / 180) *
                this.outerRadius *
                this.scale,
              -Math.sin(((18 + i * 72) * Math.PI) / 180) *
                this.outerRadius *
                this.scale
            );
            ctx.lineTo(
              Math.cos(((54 + i * 72) * Math.PI) / 180) *
                this.innerRadius *
                this.scale,
              -Math.sin(((54 + i * 72) * Math.PI) / 180) *
                this.innerRadius *
                this.scale
            );
          }
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      class Snowflake {
        constructor() {
          this.reset(true);
        }
        reset(initial = false) {
          this.x = Math.random() * width;
          this.y = initial ? Math.random() * height : -20;
          this.z = Math.random() * 1000 - 500;
          this.speed = 1 + Math.random() * 2;
          this.baseSize = 2 + Math.random() * 3;
          this.opacity = 0.3 + Math.random() * 0.4;
        }
        update() {
          this.y += this.speed;
          if (this.y > height + 20) this.reset();
        }
        draw(ctx) {
          const scale =
            config.focalLength / (config.focalLength + this.z + 600);
          const size = this.baseSize * scale;
          if (size <= 0.2) return;
          ctx.globalAlpha = this.opacity * (scale > 1 ? 1 : scale);
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      class MagicParticle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 4 + 1;
          this.speedX = (Math.random() - 0.5) * 1;
          this.speedY = (Math.random() - 0.5) * 1 + 0.5;
          this.color = `hsl(${Math.random() * 60 + 20}, 100%, 70%)`;
          this.life = 1;
        }
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.life -= 0.02;
        }
        draw(ctx) {
          ctx.fillStyle = this.color;
          ctx.globalAlpha = this.life;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function getRealisticTreeColor(yNorm, rNormFromCenter) {
        let h = 140 + Math.random() * 15;
        let s = 45;
        let l = 10 + rNormFromCenter * 20 + yNorm * 10;
        if (rNormFromCenter < 0.4) {
          l *= 0.6;
          s *= 0.8;
        }
        return `hsl(${h}, ${s}%, ${l}%)`;
      }

      function init() {
        renderList = [];
        snow = [];
        magicParticles = [];
        santaTrail = [];
        fallingGifts = [];
        animationFrameCount = 0;
        globalLightState.cycleFrame = 0;
        santaState = { flying: true, timer: 0, giftDropped: false };

        renderList.push(new SnowBase());
        santa = new SantaSleigh();

        for (let i = 0; i < 400; i++) {
          let y = Math.random() * config.trunkHeight;
          let r = Math.sqrt(Math.random()) * config.trunkRadius;
          let angle = Math.random() * Math.PI * 2;
          renderList.push(
            new TrunkPart(r * Math.cos(angle), y, r * Math.sin(angle))
          );
        }
        for (let i = 0; i < config.leafCount; i++) {
          let yNorm = Math.pow(Math.random(), 1.2);
          let y = config.trunkHeight + yNorm * config.treeHeight;
          let layerEffect =
            0.8 + 0.2 * Math.sin(yNorm * Math.PI * (config.layerCount * 2.2));
          let maxRadiusAtY = config.baseRadius * (1 - yNorm) * layerEffect;
          let r = Math.sqrt(Math.random()) * maxRadiusAtY;
          let angle = Math.random() * Math.PI * 2;
          let tx = r * Math.cos(angle);
          let tz = r * Math.sin(angle);
          renderList.push(
            new DirectionalLeaf(
              tx,
              y,
              tz,
              getRealisticTreeColor(yNorm, r / maxRadiusAtY)
            )
          );
        }
        for (let i = 0; i < config.lightCount; i++) {
          let t = i / (config.lightCount - 1);
          let y = config.trunkHeight + Math.pow(t, 1.5) * config.treeHeight;
          let angle =
            t * config.lightSpiralTurns * Math.PI * 2 + Math.random() * 0.5;
          let actualYNorm = (y - config.trunkHeight) / config.treeHeight;
          let smoothConeRadius = config.baseRadius * (1 - actualYNorm);
          let currentRadius = smoothConeRadius * 1.05;
          currentRadius += (Math.random() - 0.5) * 3;
          let tx = currentRadius * Math.cos(angle);
          let tz = currentRadius * Math.sin(angle);
          renderList.push(new Light(tx, y, tz));
        }
        for (let i = 0; i < config.giftCount + config.stockingCount; i++) {
          let yNorm = Math.random() * 0.85;
          let y = config.trunkHeight + yNorm * config.treeHeight;
          let smoothConeRadius = config.baseRadius * (1 - yNorm);
          let currentRadius = smoothConeRadius * 1.15;
          let angle = Math.random() * Math.PI * 2;
          let tx = currentRadius * Math.cos(angle);
          let tz = currentRadius * Math.sin(angle);
          if (i < config.giftCount) renderList.push(new GiftBox(tx, y, tz));
          else renderList.push(new Stocking(tx, y, tz));
        }
        renderList.push(new StarTop());
        for (let i = 0; i < 150; i++) snow.push(new Snowflake());
      }

      function resetAnimation() {
        init();
        const msg = document.querySelector(".message");
        msg.style.animation = "none";
        msg.offsetHeight;
        msg.style.animation = "fadeInMessage 2s forwards";
        msg.style.animationDelay = "1s";
      }

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        init();
      }

      const onMove = (clientX, clientY) => {
        mouseX = clientX;
        mouseY = clientY;
        for (let i = 0; i < 3; i++)
          magicParticles.push(new MagicParticle(mouseX, mouseY));
      };

      canvas.addEventListener("mousemove", (e) => onMove(e.clientX, e.clientY));
      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          onMove(e.touches[0].clientX, e.touches[0].clientY);
        },
        { passive: false }
      );
      window.addEventListener("resize", resize);

      function animate() {
        ctx.clearRect(0, 0, width, height);
        animationFrameCount++;
        if (config.autoRotate) currentAngleY += config.rotationSpeed;

        // Global Light Logic
        const WAVE_PERIOD = 400;
        const BLINK_PERIOD = 40;
        const WAVE_DURATION_FRAMES = WAVE_PERIOD * 1.3;
        const BLINK_CYCLES = 3;
        const TOTAL_CYCLE =
          WAVE_DURATION_FRAMES + BLINK_PERIOD * BLINK_CYCLES * 2;

        let currentCycleFrame =
          (animationFrameCount * config.assemblySpeedMult) % TOTAL_CYCLE;

        if (currentCycleFrame < WAVE_DURATION_FRAMES) {
          globalLightState.mode = "WAVE";
          globalLightState.wavePos =
            (currentCycleFrame / WAVE_DURATION_FRAMES) * 1.3;
        } else {
          globalLightState.mode = "BLINK";
          let blinkTime = currentCycleFrame - WAVE_DURATION_FRAMES;
          let blinkIndex = Math.floor(blinkTime / BLINK_PERIOD);
          globalLightState.blinkOn = blinkIndex % 2 === 0;
        }

        // --- SANTA FLIGHT & GIFT DROP LOGIC ---
        santaState.timer++;
        if (santaState.flying) {
          let progress = santaState.timer / config.santaFlightDuration;
          if (progress >= 1.0) {
            santaState.flying = false;
            santaState.timer = 0;
            santaState.giftDropped = false;
          } else {
            let canDrop = santa.updateFlightPath(progress);
            santa.project(currentAngleY);

            if (canDrop && !santaState.giftDropped) {
              fallingGifts.push(new FallingGift(santa.tx, santa.ty, santa.tz));
              santaState.giftDropped = true;
            }
            // T·∫°o hi·ªáu ·ª©ng b·ª•i sao d√†y h∆°n
            santaTrail.push(
              new SantaTrailParticle(santa.tx, santa.ty, santa.tz)
            );
            if (animationFrameCount % 2 === 0)
              santaTrail.push(
                new SantaTrailParticle(santa.tx, santa.ty, santa.tz)
              );
          }
        } else {
          if (santaState.timer > config.santaWaitDuration) {
            santaState.flying = true;
            santaState.timer = 0;
          }
        }

        snow.forEach((s) => {
          s.update();
          s.draw(ctx);
        });

        for (let i = 0; i < magicParticles.length; i++) {
          magicParticles[i].update();
          magicParticles[i].draw(ctx);
          if (magicParticles[i].life <= 0) {
            magicParticles.splice(i, 1);
            i--;
          }
        }

        for (let i = 0; i < santaTrail.length; i++) {
          santaTrail[i].project(currentAngleY);
          santaTrail[i].updateLife();
          santaTrail[i].draw(ctx);
          if (santaTrail[i].life <= 0) {
            santaTrail.splice(i, 1);
            i--;
          }
        }

        // --- C·∫¨P NH·∫¨T & V·∫º QU√Ä ƒêANG R∆†I ---
        for (let i = 0; i < fallingGifts.length; i++) {
          fallingGifts[i].updateFall();
          fallingGifts[i].project(currentAngleY);
          if (fallingGifts[i].isLanded) {
            let newGift = new GiftBox(
              fallingGifts[i].tx,
              fallingGifts[i].ty,
              fallingGifts[i].tz
            );
            newGift.delay = 0;
            newGift.scale = 1;
            renderList.push(newGift);
            fallingGifts.splice(i, 1);
            i--;
          } else {
            fallingGifts[i].draw(ctx);
          }
        }

        renderList.forEach((obj) => {
          obj.updatePosition(animationFrameCount);
          obj.project(currentAngleY);
        });

        renderList.sort((a, b) => b.rz - a.rz);

        renderList.forEach((obj) => {
          if (obj instanceof DirectionalLeaf) obj.draw(ctx, currentAngleY);
          else if (obj instanceof Light) obj.draw(ctx, animationFrameCount);
          else if (obj instanceof StarTop) obj.draw(ctx, animationFrameCount);
          else if (obj instanceof GiftBox) obj.draw(ctx);
          else if (obj instanceof Stocking) obj.draw(ctx);
          else if (obj instanceof SnowBase) obj.draw(ctx);
          else obj.draw(ctx);
        });

        // V·∫Ω Santa sau c√πng v√¨ bay ngay tr√™n ƒë·ªânh
        if (santaState.flying) santa.draw(ctx, currentAngleY);

        requestAnimationFrame(animate);
      }

      resize();
      animate();
    </script>
  </body>
</html>
